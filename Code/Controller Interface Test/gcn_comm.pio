.program gcn_comm
.side_set 1 pindirs

.define public T1 4
.define public T2 12

;State machine starts in the transmit state
PUBLIC tx_start:
    out y, 32           side 0

tx_loop:
    jmp y-- tx_proc     side 0
    jmp do_stop         side 0

tx_proc:
    out x, 1            side 0 ;Shift the next bit into the X register. Keep the pin high-z
    jmp !x do_zero      side 1 [T1 - 1] ;Branch on the bit we shifted out. Drive low to start. Delay to keep the pin low the minimum amount of time (1uS for a one)

do_one:
    nop                 side 0 [T2 - 4] ;Switch back to high-z so the bit goes high. Wait here the amount of time a 1 is high. Jump back to the loop if there is more data
    jmp tx_loop         side 0 ;Keep the pin in high-z. OSRE is true when the shift count matches the auto-pull amount set by l_ControllerCommWrite in ControllerComm.c

do_zero:
    nop                 side 1 [T2 - T1 - 1] ;Keep the output low for the rest of the 0 low cycle
    nop                 side 0 [T1 - 4] ; Go back to idle high.
    jmp tx_loop         side 0 ;Keep the pin in high-z. OSRE is true when the shift count matches the auto-pull amount set by l_ControllerCommWrite in ControllerComm.c

do_stop:
    nop                 side 1 [T1 - 1] ;Set the output low to match a 1 bit
    jmp rx_start        side 0 [T1 - 1] ;Set the pin back to a high-z state. Wait before jumping to let the pin charge back to high

PUBLIC rx_start:
    mov ISR, NULL       side 0
    wait 0 pin 0        side 0       ;Wait for the falling edge
    nop                 side 0 [6]   ;Delay until halfway through the bit
    
bitloop:
    in pins, 1                  side 0      ;Shift the pin value into the ISR
    jmp pin idle_check_start    side 0      ;If the pin is high, this could be the start of the stop bit

    wait 1 pin 0                side 0      ;Wait for the pin to go back high
    wait 0 pin 0                side 0      ;Wait for the pin to fall at the next bit
    nop                         side 0 [5]  ;Delay until half way through the bit
    jmp bitloop                 side 0      ;Jump back to the loop start

idle_check_start:
    set y, T2                   side 0      ;Set a counter to a long count to find the idle
                                            ;Long enough to handle variety of bit timings

idle_check_l1:
    jmp pin idle_check_l2       side 0      ;If the pin is still high, jump to decrement the count
    nop                         side 0 [5]  ;If the pin is low, a new bit is started. Wait until half way through
    jmp bitloop                 side 0      ;Jump back to the loop

idle_check_l2:
    jmp y-- idle_check_l1       side 0      ;Decrement the count. When zero, the stop bit is detected and falls through

signal:
    push                side 0          ;Push the ISR value
    jmp tx_start        side 0          ;Jump back to the start and wait for the next bit

% c-sdk {
#include "hardware/clocks.h"

static inline void gcn_comm_program_init(PIO pio, uint sm, uint offset, uint pin, float freq) {

    pio_gpio_init(pio, pin);

    pio_sm_config c = gcn_comm_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, pin);
    sm_config_set_in_pins(&c, pin);
    sm_config_set_jmp_pin(&c, pin);
    sm_config_set_in_shift(&c, false, true, 0);
    sm_config_set_out_shift(&c, false, true, 0);

    int cycles_per_bit = gcn_comm_T1 + gcn_comm_T2;
    float div = clock_get_hz(clk_sys) / (freq * cycles_per_bit);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

static inline uint gcn_switch_tx (uint offset) {
    // encode a "jmp reset_bus side 0" instruction for the state machine
    return pio_encode_jmp (offset + gcn_comm_offset_tx_start) | pio_encode_sideset (1, 0);
}

static inline uint gcn_switch_rx (uint offset) {
    // encode a "jmp reset_bus side 0" instruction for the state machine
    return pio_encode_jmp (offset + gcn_comm_offset_rx_start) | pio_encode_sideset (1, 0);
}
%}